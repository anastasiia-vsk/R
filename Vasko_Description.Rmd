---
title: "Описова аналітика"
output: html_notebook
---

### **Завдання 1.**

Створіть змінну *lvl*, яка містить наступні числові елементи: 8, 10, 10, 1, 10, 10, 8, 12, 1, 12.

```{r}
lvl <- c(8, 10, 10, 1, 10, 10, 8, 12, 1, 12)
lvl
```

Виконайте наступні завдання:

-   обчисліть суму елементів *lvl*;

```{r}
sum_lvl <- sum(lvl)
sum_lvl
```

-   обчисліть середнє елементів *lvl*;

```{r}
mean_lvl <- mean(lvl)
mean_lvl
```

-   визначте медіану елементів *lvl*;

```{r}
median_lvl <- median(lvl)
median_lvl
```

-   визначте з допомогою R довжину змінної *lvl*;

```{r}
length_lvl <- length(lvl)
length_lvl
```

-   обчисліть стандартне відхилення елементів *lvl*;

```{r}
sd_lvl <- sd(lvl)
sd_lvl
```

-   округліть стандартне відхилення до двох знаків після коми.

```{r}
round(sd_lvl, 2)
```

### **Завдання 2.**

Уявимо, що ви відстежуєте пробіг автомобіля після кожної заправки. Після останніх восьми заправок пробіг був:

65311    65624     65908     66219      66499      66821     67145     67447.

Введіть ці числа в R.

```{r}
mileage <- c(65311, 65624, 65908, 66219, 66499, 66821, 67145, 67447)
mileage
```

Використайте функцію *diff()* до цих даних. Що ви отримаєте як результат? Ви повинні побачити кількість миль між заправками.

```{r}
trip <- diff(mileage)
trip
```

***ВІДПОВІДЬ: Функція diff() обчислює різницю між сусідніми значеннями вектора, тож я справді побачила кількість миль між заправками.***

Використайте функцію *max(), mean() і min(),* щоб обчислити максимальний, середній і мінімальний пробіг між заправками.

```{r}
max(trip)
```

```{r}
mean(trip)
```

```{r}
min(trip)
```

### **Завдання 3.**

Уявіть, що вам потрібно купити устаткування для вашої фабрики і у вас є 2 варіанти для вибору. Перед прийняттям остаточного рішення, ви вибрали 10 показників ефективності з кожного варіанту. Якщо б ваше остаточне рішення будувалося на цих замірах, яке устаткування ви б вибрали?

Устаткування 1: 151.2, 150.5, 149.2, 147.5, 152.9, 152.0, 151.3, 149.7, 149.4, 150.7

Устаткування 2: 151.9, 151.4, 150.3, 151.2, 151.0, 150.2, 151.2, 151.4, 150.4, 151.7

```{r}
u_1 <- c(151.2, 150.5, 149.2, 147.5, 152.9, 152.0, 151.3, 149.7, 149.4, 150.7)
cat("Устаткування 1:", u_1)

u_2 <- c(151.9, 151.4, 150.3, 151.2, 151.0, 150.2, 151.2, 151.4, 150.4, 151.7)
cat("\t Устаткування 2:", u_2)
```

***Можна подивитися на середній показник ефективності.***

```{r}
mean_u_1 <- mean(u_1)
mean_u_2 <- mean(u_2)

cat("Середній показник ефективності для устаткування 1:", mean_u_1, "\n")
cat("Середній показник ефективності для устаткування 2:", mean_u_2, "\n")
```

***ВІДПОВІДЬ: Проаналізувавши середні показники ефективності, я побачила, що устаткування №2 має більше значення, тож обрала б його.***

***Згадала, що на парі Ви зазначили, що варто автоматично визначити краще устаткування.\
Тож написала другий варіант:***

```{r}
if (max(mean_u_1, mean_u_2) == mean_u_1){
  print("Варто обрати перше устаткування")
} else{
  print("Варто обрати друге устаткування")
}
```

***Результати обох варіантів співпали)***

### **Завдання 4.**

Створіть вектор зросту двадцяти учнів класу:

100, 106, 121, 111, 109, 111, 103, 117, 114, 108, 111, 105, 120, 116, 104, 103, 108, 111, 101, 120.

```{r}
student_height <- c(100, 106, 121, 111, 109, 111, 103, 117, 114, 108, 111, 105, 120, 116, 104, 103, 108, 111, 101, 120)
student_height
```

Який учень знаходиться посередині цього списку (за зростом)?

***учень посередині - медіана***

```{r}
sort(student_height)
```

```{r}
middle_student <- median(sort(student_height))
middle_student
```

*так вийшло, що у нас парна кількість студентів, тож медіана вийшла 110*

Який зріст є найбільш популярним?

***найбільш популярний - це мода***

```{r}
popular_height <- names(which.max(table(student_height)))
cat("Найбільш популярний зріст:", popular_height)
```

### **Завдання 5.**

Обчисліть квантилі, квартилі, *IQR* і стандартну похибку на основі даних з попереднього завдання.

```{r}
quantile(student_height)
```

```{r}
IQR(student_height)
```

```{r}
standard_error <- sd(student_height) / sqrt(length(student_height))
round(standard_error, 3)
```

### **Завдання 6.**

Розрахуйте стандартне відхилення для даних із завдання 4 за допомогою формули і порівняйте результати з використанням функції *sd*(). Чи будуть результати однакові?

```{r}
variance_formula <- sum((student_height - mean(student_height))^2) / (length(student_height) - 1)
std_dev_formula <- sqrt(variance_formula)
std_dev_formula
```

```{r}
sd(student_height)
```

**`ВІДПОВІДЬ: Так, результати співпали.`**

### **Завдання 7.**

Завантажте дані з двох стовпців таблиці у два вектори. Визначте скошеність у даних візуально з використанням засобів розвідувальної аналітики та з допомогою метрик описової аналітики. Інтерпретуйте результати.

```{r}
vector_1 <- c(212, 869, 220, 654, 511, 624, 420, 121, 428, 865, 799, 405, 230, 670, 870, 366, 99, 55, 489, 312, 493, 163, 221, 84, 144, 48, 375, 86, 168, 100)

vector_1
```

```{r}
vector_2 <- c(586, 760, 495, 678, 559, 415, 370, 659, 119, 288, 241, 787, 522, 207, 160, 526, 656, 848, 720, 676, 581, 929, 653, 661, 770, 800, 529, 975, 995, 947)

vector_2
```

Визначте скошеність у даних візуально з використанням засобів розвідувальної аналітики та з допомогою метрик описової аналітики. Інтерпретуйте результати.

-   *варіант із використанням hist()*

```{r}
hist(vector_1, main = "Гістограма для вектору 1", xlab = "Значення", ylab = "Частота", col = "skyblue", breaks = 10)
```

```{r}
hist(vector_2, main = "Гістограма для вектору 2", xlab = "Значення", ylab = "Частота", col = "lightgreen", breaks = 10)
```

-   *варіант із використанням plot()*

```{r}
plot(density(vector_1), main = "Графік розподілу для вектору 1", xlab = "Значення", ylab = "Щільність", col = "blue")
```

```{r}
plot(density(vector_2), main = "Графік розподілу для вектору 2", xlab = "Значення", ylab = "Щільність", col = "green")
```

***Зараз я бачу, що дані першого вектора скошені вправо, дані другого вектора - вліво.***

***Перевіримо це ще аналітично:***

```{r}
# install.packages("moments")
library("moments")

skewness(vector_1)
skewness(vector_2)
```

**`ВИСНОВКИ: Підтвердилося.`**

**`Метрика розподілу першого вектора більше 0, отже він скошений вправо.`**

**`Метрика розподілу другого вектора менше 0, отже він скошений вліво.`**
